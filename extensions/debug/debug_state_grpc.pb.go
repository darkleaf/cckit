// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package debug

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// DebugStateClient is the client API for DebugState service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DebugStateClient interface {
	// Clear all state or, if prefixes are defined, only prefix matched
	StateClean(ctx context.Context, in *Prefixes, opts ...grpc.CallOption) (*PrefixesMatchCount, error)
	// Get keys list, returns all keys or, if prefixes are defined, only prefix matched
	StateKeys(ctx context.Context, in *Prefix, opts ...grpc.CallOption) (*CompositeKeys, error)
	// Get state value by key
	StateGet(ctx context.Context, in *CompositeKey, opts ...grpc.CallOption) (*Value, error)
	// Put state value
	StatePut(ctx context.Context, in *Value, opts ...grpc.CallOption) (*Value, error)
	// Delete state value
	StateDelete(ctx context.Context, in *CompositeKey, opts ...grpc.CallOption) (*Value, error)
}

type debugStateClient struct {
	cc grpc.ClientConnInterface
}

func NewDebugStateClient(cc grpc.ClientConnInterface) DebugStateClient {
	return &debugStateClient{cc}
}

func (c *debugStateClient) StateClean(ctx context.Context, in *Prefixes, opts ...grpc.CallOption) (*PrefixesMatchCount, error) {
	out := new(PrefixesMatchCount)
	err := c.cc.Invoke(ctx, "/cckit.extension.debug.DebugState/StateClean", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugStateClient) StateKeys(ctx context.Context, in *Prefix, opts ...grpc.CallOption) (*CompositeKeys, error) {
	out := new(CompositeKeys)
	err := c.cc.Invoke(ctx, "/cckit.extension.debug.DebugState/StateKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugStateClient) StateGet(ctx context.Context, in *CompositeKey, opts ...grpc.CallOption) (*Value, error) {
	out := new(Value)
	err := c.cc.Invoke(ctx, "/cckit.extension.debug.DebugState/StateGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugStateClient) StatePut(ctx context.Context, in *Value, opts ...grpc.CallOption) (*Value, error) {
	out := new(Value)
	err := c.cc.Invoke(ctx, "/cckit.extension.debug.DebugState/StatePut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugStateClient) StateDelete(ctx context.Context, in *CompositeKey, opts ...grpc.CallOption) (*Value, error) {
	out := new(Value)
	err := c.cc.Invoke(ctx, "/cckit.extension.debug.DebugState/StateDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DebugStateServer is the server API for DebugState service.
// All implementations must embed UnimplementedDebugStateServer
// for forward compatibility
type DebugStateServer interface {
	// Clear all state or, if prefixes are defined, only prefix matched
	StateClean(context.Context, *Prefixes) (*PrefixesMatchCount, error)
	// Get keys list, returns all keys or, if prefixes are defined, only prefix matched
	StateKeys(context.Context, *Prefix) (*CompositeKeys, error)
	// Get state value by key
	StateGet(context.Context, *CompositeKey) (*Value, error)
	// Put state value
	StatePut(context.Context, *Value) (*Value, error)
	// Delete state value
	StateDelete(context.Context, *CompositeKey) (*Value, error)
	mustEmbedUnimplementedDebugStateServer()
}

// UnimplementedDebugStateServer must be embedded to have forward compatible implementations.
type UnimplementedDebugStateServer struct {
}

func (UnimplementedDebugStateServer) StateClean(context.Context, *Prefixes) (*PrefixesMatchCount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StateClean not implemented")
}
func (UnimplementedDebugStateServer) StateKeys(context.Context, *Prefix) (*CompositeKeys, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StateKeys not implemented")
}
func (UnimplementedDebugStateServer) StateGet(context.Context, *CompositeKey) (*Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StateGet not implemented")
}
func (UnimplementedDebugStateServer) StatePut(context.Context, *Value) (*Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatePut not implemented")
}
func (UnimplementedDebugStateServer) StateDelete(context.Context, *CompositeKey) (*Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StateDelete not implemented")
}
func (UnimplementedDebugStateServer) mustEmbedUnimplementedDebugStateServer() {}

// UnsafeDebugStateServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DebugStateServer will
// result in compilation errors.
type UnsafeDebugStateServer interface {
	mustEmbedUnimplementedDebugStateServer()
}

func RegisterDebugStateServer(s grpc.ServiceRegistrar, srv DebugStateServer) {
	s.RegisterService(&DebugState_ServiceDesc, srv)
}

func _DebugState_StateClean_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Prefixes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugStateServer).StateClean(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cckit.extension.debug.DebugState/StateClean",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugStateServer).StateClean(ctx, req.(*Prefixes))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugState_StateKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Prefix)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugStateServer).StateKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cckit.extension.debug.DebugState/StateKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugStateServer).StateKeys(ctx, req.(*Prefix))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugState_StateGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompositeKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugStateServer).StateGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cckit.extension.debug.DebugState/StateGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugStateServer).StateGet(ctx, req.(*CompositeKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugState_StatePut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugStateServer).StatePut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cckit.extension.debug.DebugState/StatePut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugStateServer).StatePut(ctx, req.(*Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugState_StateDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompositeKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugStateServer).StateDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cckit.extension.debug.DebugState/StateDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugStateServer).StateDelete(ctx, req.(*CompositeKey))
	}
	return interceptor(ctx, in, info, handler)
}

// DebugState_ServiceDesc is the grpc.ServiceDesc for DebugState service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DebugState_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cckit.extension.debug.DebugState",
	HandlerType: (*DebugStateServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StateClean",
			Handler:    _DebugState_StateClean_Handler,
		},
		{
			MethodName: "StateKeys",
			Handler:    _DebugState_StateKeys_Handler,
		},
		{
			MethodName: "StateGet",
			Handler:    _DebugState_StateGet_Handler,
		},
		{
			MethodName: "StatePut",
			Handler:    _DebugState_StatePut_Handler,
		},
		{
			MethodName: "StateDelete",
			Handler:    _DebugState_StateDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "debug/debug_state.proto",
}
